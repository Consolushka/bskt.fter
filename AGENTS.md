# AGENTS.md

Документ для ИИ-агентов, которые вносят изменения в проект.

## 1. Цель проекта

Сервис собирает баскетбольную статистику из внешних провайдеров и сохраняет данные в PostgreSQL:
- игры,
- командную статистику,
- статистику игроков,
- служебные watermark-метки для опроса.

## 2. Актуальная модель запуска

Инфраструктура:
- Docker используется для PostgreSQL (`docker-compose`, сервис `db`) и для самого приложения (контейнер `dockhost`).
- Деплой осуществляется через `docker/dockhost/Dockerfile`.
- Скрипт `startup.sh` автоматически запускает все тесты (`go test ./...`) перед стартом приложения. Если тесты падают, приложение не запускается.

Основной рантайм:
- `app/cmd/scheduler/main.go` — фоновый процесс.

Дополнительно:
- `app/cmd/debug-server/main.go` — легкий HTTP-сервер для ручного триггера обработки.

Текущая стратегия опроса:
- распределенная модель: каждый активный турнир обслуживается отдельной горутиной-воркером,
- интервал опроса для каждого воркера задается через `SCHEDULER_POLL_INTERVAL` (в минутах, по умолчанию 30),
- "шахматный" старт: запуск воркеров разнесен во времени на интервал `SCHEDULER_STAGGER_INTERVAL_MINUTES` (по умолчанию 5), чтобы распределить нагрузку на API и БД,
- для каждого турнира хранится своя watermark-метка в БД (`poll_watermarks`).

## 3. Архитектурный стиль

Проект следует гексагональной архитектуре (ports/adapters):
- `app/internal/core` — доменные модели,
- `app/internal/ports` — интерфейсы,
- `app/internal/adapters` — реализации интерфейсов (БД, провайдеры),
- `app/internal/service` — use-case/оркестрация,
- `app/internal/infra` — низкоуровневые клиенты внешних API,
- `app/database/migrations` — SQL-миграции.

Правило:
- новый репозиторий/внешняя зависимость сначала задается в `ports`,
- затем реализуется в соответствующем adapter-пакете,
- сервисы зависят от интерфейсов, а не от concrete-типов.

## 4. Паттерн файлов и именования

### 4.1 Репозитории

Для каждого репозитория:
- интерфейс в `app/internal/ports/*_repo.go`,
- адаптер в `app/internal/adapters/<name>_repo/gorm.go`,
- реализация GORM-адаптера использует структуру `Gorm` и ресивер `g`,
- конструктор `NewGormRepo(...)`.

**Правила именования методов:**
- Без суффикса сущности в single-entity репозиториях (например, `FirstOrCreate` вместо `FirstOrCreateTeam`).
- Поиск/создание: `FirstOrCreate`.
- Проверка существования: `Exists`.
- Списки: `ListActive`, `ListBy...`.
- Получение одного объекта: `Get`.

### 4.2 Модели

- доменные модели лежат в соответствующих пакетах `app/internal/core/<domain>`.
- не смешивать модели разных доменов в одном пакете без необходимости.

### 4.3 Моки

- моки лежат рядом с адаптером/пакетом, где используются,
- mock обязан соответствовать текущему интерфейсу из `ports`.

## 5. Поток обработки данных

Базовый поток:
1. scheduler запускает независимые воркеры для каждого активного турнира с задержкой между стартами.
2. Каждый воркер циклично опрашивает данные, используя `poll_watermarks` своего турнира.
3. orchestrator и processor запрашивают и обогащают данные через stats provider.
3. persistence сохраняет данные в БД, после чего обновляется watermark турнира.

Важно для лимитов API:
- `API_NBA` реализован двухфазно:
  - `GetGamesStatsByPeriod` — легкий листинг игр,
  - `EnrichGameStats` — тяжелая догрузка только для новых игр.

## 6. База данных и миграции

- миграции: `app/database/migrations`.
- перед изменением моделей проверить существующие индексы/уникальности.
- критерии проверки существования игры должны соответствовать реальному unique-индексу БД.

## 7. Тестовая стратегия

Используется:
- `testing`,
- `gomock`,
- `testify/assert` и `testify/suite`.
- Линтинг: `golangci-lint` (включая `testifylint`), конфиг в `.golangci.yml`.

### 7.1 Тестирование репозиториев (GORM)
Для тестирования GORM-адаптеров используется SQLite в памяти (in-memory):
- Утилита для инициализации: `app/pkg/dbtest/sqlite.go`.
- Паттерн: использование `testify/suite` для структурирования тестов.
- Изоляция и производительность (Транзакционный паттерн):
  - База данных и миграции инициализируются ОДИН раз для всего набора тестов в `SetupSuite`.
  - Каждый конкретный тест запускается внутри транзакции (`db.Begin()`), которая создается в `SetupTest`.
  - После завершения каждого теста транзакция откатывается (`Rollback()`) в `TearDownTest`, что гарантирует чистоту базы для следующего теста без необходимости пересоздания таблиц.
  - Репозиторий должен инициализироваться транзакционным объектом БД (хранится в `s.tx`).
- **Критически важно:** использовать `s.Require().NoError(err)` вместо `s.NoError(err)` для проверки ошибок в тестах (согласно правилу `testifylint: require-error`).

### 7.2 Общие требования к новым изменениям:
- happy-path,
- error-path,
- continue/skip-ветки,
- проверка взаимодействия с mock-зависимостями.

Если меняется сигнатура интерфейса:
- обновить все моки,
- обновить тесты сервисов/оркестраторов,
- убедиться, что пакет(ы) с этими тестами компилируются и проходят.
- убедиться, что `make lint` проходит.

## 8. Правила изменения кода

1. Не нарушать разделение по слоям.
2. Не тянуть adapter-зависимости напрямую в `core`.
3. Не добавлять новый флоу без порта/контракта.
4. Для логики с ограничениями внешних API — использовать встроенные в infra-клиенты лимитеры, настраиваемые через `.env`.
5. Для конкурентного исполнения избегать race в goroutine-замыканиях.
6. Логи должны быть информативными и не шумными:
   - не логировать целые тяжелые структуры, если достаточно ключей идентификации;
   - в error-логах добавлять только поля, участвующие в проверке/поиске сущности;
   - дублирующие логи в слоях persistence/service не добавлять.

## 9. Чеклист для ИИ-агента перед завершением задачи

1. Обновлены ли интерфейсы и их реализации синхронно?
2. Обновлены ли моки под текущие интерфейсы?
3. Добавлены/обновлены тесты под новую ветвящуюся логику?
4. Применимы ли миграции к чистой базе?
5. Обновлены ли `README.md` и этот `AGENTS.md`, если поведение/архитектура изменилась?

## 10. Обязательное правило актуализации

КРИТИЧНО:

Любое изменение, которое затрагивает архитектуру, флоу данных, контракты интерфейсов, стратегию опроса, структуру БД, правила тестирования или правила разработки, ОБЯЗАТЕЛЬНО должно сопровождаться обновлением этого файла `AGENTS.md`.

Если после изменения код и `AGENTS.md` расходятся — задача считается выполненной некорректно.
